// Copyright 2015, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License,
// version 1.0 (EPL), with the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may
// distribute libraries generated by LoxiGen (LoxiGen Libraries)
// under the terms of your choice, provided that copyright and
// licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i)
// included in the LoxiGen Libraries, if distributed in source code
// form and (ii) included in any documentation for the LoxiGen
// Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc.
// This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or
// LOXI Exception. You may obtain a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an "AS
// IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the EPL for the specific language
// governing permissions and limitations under the EPL.

// IVS supports running sandboxed Lua code as the forwarding pipeline.
// This extension allows the controller to upload the Lua code, send
// commands to it, and receive async notifications.
//
// Most of the data passed between the controller and the Lua code is
// opaque to the rest of the switch. It's assumed that the controller
// is tightly coupled to the Lua code it uploaded, so there's no need
// to version the protocol between them.

#version 4
#version 5
#version 6

// Upload chunks of Lua code to the switch
//
// If the MORE flag is not set, the old VM will be cleaned up and
// a new VM will be initialized with the uploaded code. Each chunk
// of code is executed in the VM in the order it was received.
//
// If the FORCE flag is not set, the switch will check to see if the
// old and new code is identical. If they are identical the message
// will be ignored.
//
// As part of the VM cleanup, all gentables registered by Lua code
// will be unregistered.
//
// Consecutive messages with the same filename are concatenated,
// to support chunks larger than 64K.

enum ofp_bsn_lua_upload_flags(wire_type=uint16_t, bitmask=True) {
    OFP_BSN_LUA_UPLOAD_MORE = 0x1,
    OFP_BSN_LUA_UPLOAD_FORCE = 0x2,
};

struct of_bsn_lua_upload : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 64;
    enum ofp_bsn_lua_upload_flags flags;
    of_str64_t filename;
    of_octets_t data;
};

// Send a command to Lua

struct of_bsn_lua_command_request : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 65;
    of_octets_t data;
};

struct of_bsn_lua_command_reply : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 66;
    of_octets_t data;
};

// Async message from Lua to the controller

struct of_bsn_lua_notification : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 67;
    of_octets_t data;
};
