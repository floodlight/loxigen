// Copyright 2013, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License,
// version 1.0 (EPL), with the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may
// distribute libraries generated by LoxiGen (LoxiGen Libraries)
// under the terms of your choice, provided that copyright and
// licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i)
// included in the LoxiGen Libraries, if distributed in source code
// form and (ii) included in any documentation for the LoxiGen
// Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc.
// This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or
// LOXI Exception. You may obtain a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an "AS
// IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the EPL for the specific language
// governing permissions and limitations under the EPL.

#version 4
#version 5
#version 6

// We have a number of switch agents that need to be configured by the
// controller and report stats. Some of them will have large tables (1000+
// entries) and so need an efficient synchronization mechanism (as can be
// accomplished using the cookie field in flowtable entries). It's a
// significant amount of work to do this from scratch for each new table.
// This extension (and the corresponding Indigo code) provides a framework
// to ease implementing new tables.

// We don't plan on replacing our use of the OpenFlow flow table and group
// table with this scheme. This is intended for controlling switch
// functionality like the ARP and LACP agents which don't map at all to
// flow-mods.

// Each switch will have a number of tables indexed by a 16-bit table ID. Each
// table has a name, id, a set of entries, and an array of checksum buckets.
// There is no order to the entries; stats requests will return them in an
// arbitrary order. The controller is expected to use the table name to
// determine the semantics of a table.

// Each entry has a key, value, stats, and checksum. The key and value are TLV
// lists given by the controller in a gentable_entry_add message. The switch must
// return these lists in stats replies exactly as it received them. The stats
// are a list of TLVs controlled by the switch. The stats are expected to
// include more than simple counters (for example, last hit time or seen TCP
// flags). The checksum is an opaque value used for table synchronization.

// LOXI includes a built-in type of_checksum_128_t, which is 128 bits but
// only requires 32-bit alignment.


// These TLV classes are used for keys, values, and stats. Like OXM, lists of
// TLVs are tightly packed without padding. TLV lists may include duplicates
// and the semantics of this is left to the particular table.
//
// If this is eventually standardized it would be good to add a "class" type
// member as in OXM.
struct of_bsn_tlv {
    uint16_t type == ?;
    uint16_t length;
};


// This message sets key=value in the given table. If key already exists in the
// table then it modifies the value, preserving stats.
//
// If the switch cannot process the message then it should reply with an error
// message. The contents of the table must not be changed in case of an error.
struct of_bsn_gentable_entry_add : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 46;
    uint16_t table_id;
    uint16_t key_length == length(key);
    of_checksum_128_t checksum;
    list(of_bsn_tlv_t) key;
    list(of_bsn_tlv_t) value;
};


// This message deletes the entry with the given key in the given table.
//
// If the switch cannot process the message then it should reply with an error
// message. The contents of the table must not be changed in case of an error.
// If the key does not exist in the table no error will be generated.
struct of_bsn_gentable_entry_delete : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 47;
    uint16_t table_id;
    list(of_bsn_tlv_t) key;
};


// This message deletes a range of table entries. The checksum_mask must be a
// prefix mask. The checksum must be zero in the bits where the checksum_mask
// is zero.
//
// The switch may fail to delete some table entries. No error messages will be
// sent, but the error_count in the reply message will be incremented.
struct of_bsn_gentable_clear_request : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 48;
    uint16_t table_id;
    pad(2);
    of_checksum_128_t checksum;
    of_checksum_128_t checksum_mask;
};

struct of_bsn_gentable_clear_reply : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 49;
    uint16_t table_id;
    pad(2);
    uint32_t deleted_count;
    uint32_t error_count;
};


// This message sets the size of the buckets array. The switch may reject this
// message if the table has entries. buckets_size must be a power of 2.
struct of_bsn_gentable_set_buckets_size : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 50;
    uint16_t table_id;
    pad(2);
    uint32_t buckets_size;
};


// Retrieve the configuration state (key, value, and checksum) for each table
// entry in a range of buckets.
//
// The checksum_mask must be a prefix mask. The checksum must be zero in the
// bits where the checksum_mask is zero.
struct of_bsn_gentable_entry_desc_stats_request : of_bsn_stats_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_request_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 2;
    uint16_t table_id;
    pad(2);
    of_checksum_128_t checksum;
    of_checksum_128_t checksum_mask;
};

struct of_bsn_gentable_entry_desc_stats_entry {
    uint16_t length;
    uint16_t key_length == length(key);
    of_checksum_128_t checksum;
    list(of_bsn_tlv_t) key;
    list(of_bsn_tlv_t) value;
};

struct of_bsn_gentable_entry_desc_stats_reply : of_bsn_stats_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_reply_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 2;
    list(of_bsn_gentable_entry_desc_stats_entry_t) entries;
};


// Retrieve the runtime state (key and stats) for each table entry in a range
// of buckets.
//
// The checksum_mask must be a prefix mask. The checksum must be zero in the
// bits where the checksum_mask is zero.
struct of_bsn_gentable_entry_stats_request : of_bsn_stats_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_request_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 3;
    uint16_t table_id;
    pad(2);
    of_checksum_128_t checksum;
    of_checksum_128_t checksum_mask;
};

struct of_bsn_gentable_entry_stats_entry {
    uint16_t length;
    uint16_t key_length == length(key);
    list(of_bsn_tlv_t) key;
    list(of_bsn_tlv_t) stats;
};

struct of_bsn_gentable_entry_stats_reply : of_bsn_stats_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_reply_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 3;
    list(of_bsn_gentable_entry_stats_entry_t) entries;
};


// Retrieve the description for all tables.
struct of_bsn_gentable_desc_stats_request : of_bsn_stats_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_request_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 4;
};

struct of_bsn_gentable_desc_stats_entry {
    uint16_t length;
    uint16_t table_id;
    of_table_name_t name;
    uint32_t buckets_size;
    uint32_t max_entries;
    pad(4);
    /* TODO properties */
};

struct of_bsn_gentable_desc_stats_reply : of_bsn_stats_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_reply_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 4;
    list(of_bsn_gentable_desc_stats_entry_t) entries;
};


// Retrieves stats for every table. This includes the total checksum, so the
// controller can quickly check whether the whole table is in sync.
//
// The checksum of a table is the sum of the checksums of all entries in the
// table.
struct of_bsn_gentable_stats_request : of_bsn_stats_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_request_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 7;
};

struct of_bsn_gentable_stats_entry {
    uint16_t table_id;
    pad(2);
    uint32_t entry_count;
    of_checksum_128_t checksum;
};

struct of_bsn_gentable_stats_reply : of_bsn_stats_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_reply_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 7;
    list(of_bsn_gentable_stats_entry_t) entries;
};


// Retrieves the checksum for every bucket in a table. The entries are ordered
// by bucket index.
//
// The checksum of a bucket is the sum of the checksums of all entries in the
// bucket.
struct of_bsn_gentable_bucket_stats_request : of_bsn_stats_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_request_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 5;
    uint16_t table_id;
};

struct of_bsn_gentable_bucket_stats_entry {
    of_checksum_128_t checksum;
};

struct of_bsn_gentable_bucket_stats_reply : of_bsn_stats_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type == 0xffff;
    enum ofp_stats_reply_flags flags;
    pad(4);
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 5;
    list(of_bsn_gentable_bucket_stats_entry_t) entries;
};

// Reference a gentable entry from an action list
struct of_action_bsn_gentable : of_action_bsn {
    uint16_t type == 65535;
    uint16_t len;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 5;
    uint32_t table_id;
    list(of_bsn_tlv_t) key;
};

enum of_bsn_gentable_error_code(wire_type=uint16_t) {
    OF_BSN_GENTABLE_ERROR_UNKNOWN = 0,
    OF_BSN_GENTABLE_ERROR_PARAM = 1,  // invalid parameter
    OF_BSN_GENTABLE_ERROR_TABLE_FULL = 2,
};

// BSN gentable error message
struct of_bsn_gentable_error : of_bsn_base_error {
    uint8_t version;
    uint8_t type == 1;
    uint16_t length;
    uint32_t xid;
    uint16_t err_type == 0xffff;
    uint16_t subtype == 2;
    uint32_t experimenter == 0x5c16c7;
    enum of_bsn_gentable_error_code error_code;
    uint16_t table_id;
    of_desc_str_t err_msg;
    of_octets_t data;
};
