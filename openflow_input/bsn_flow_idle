// Copyright 2013, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License,
// version 1.0 (EPL), with the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may
// distribute libraries generated by LoxiGen (LoxiGen Libraries)
// under the terms of your choice, provided that copyright and
// licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i)
// included in the LoxiGen Libraries, if distributed in source code
// form and (ii) included in any documentation for the LoxiGen
// Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc.
// This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or
// LOXI Exception. You may obtain a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an "AS
// IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the EPL for the specific language
// governing permissions and limitations under the EPL.

#version 4
#version 5

/*
 * Notification of idle flows
 *
 * This extension allows the controller to request to be notified periodically
 * about idle flows. It is very similar to the flow_removed message in standard
 * OpenFlow, but does not delete the idle flows.
 *
 * If the extension is enabled using of_bsn_flow_idle_enable_set_request and
 * the OFPFF_BSN_SEND_IDLE bit is set in the flow-mod, then the idle_timeout
 * field in the flow-mod is not used for standard flow expiration. Instead,
 * the switch will send an of_bsn_flow_idle message every idle_timeout seconds
 * if the flow was not used during that period.
 */

struct of_bsn_flow_idle_enable_set_request : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 36;
    uint32_t enable;        // 0 to disable the extension, 1 to enable it
};

struct of_bsn_flow_idle_enable_set_reply : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 37;
    uint32_t enable;        // Resulting state, 0 disabled, 1 enabled
    uint32_t status;        // Result code: 0 success
};

struct of_bsn_flow_idle_enable_get_request : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 38;
};

struct of_bsn_flow_idle_enable_get_reply : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 39;
    uint32_t enabled;       // 0 if feature is disabled; 1 if feature enabled
};

struct of_bsn_flow_idle : of_bsn_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter == 0x5c16c7;
    uint32_t subtype == 40;
    uint64_t cookie;
    uint16_t priority;
    uint8_t table_id;
    pad(5); // align to 8 bytes
    of_match_t match;
};
