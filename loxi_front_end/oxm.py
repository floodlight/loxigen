# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

import of_g

oxm_types = dict(
    in_port               = "of_port_no_t",
    in_port_masked        = "of_port_no_t",
    in_phy_port           = "of_port_no_t",
    in_phy_port_masked    = "of_port_no_t",
    metadata              = "uint64_t",
    metadata_masked       = "uint64_t",
    eth_dst               = "of_mac_addr_t",
    eth_dst_masked        = "of_mac_addr_t",
    eth_src               = "of_mac_addr_t",
    eth_src_masked        = "of_mac_addr_t",
    eth_type              = "uint16_t",
    eth_type_masked       = "uint16_t",
    vlan_vid              = "uint16_t",
    vlan_vid_masked       = "uint16_t",
    vlan_pcp              = "uint8_t",
    vlan_pcp_masked       = "uint8_t",
    ip_dscp               = "uint8_t",
    ip_dscp_masked        = "uint8_t",
    ip_ecn                = "uint8_t",
    ip_ecn_masked         = "uint8_t",
    ip_proto              = "uint8_t",
    ip_proto_masked       = "uint8_t",
    ipv4_src              = "uint32_t",
    ipv4_src_masked       = "uint32_t",
    ipv4_dst              = "uint32_t",
    ipv4_dst_masked       = "uint32_t",
    tcp_src               = "uint16_t",
    tcp_src_masked        = "uint16_t",
    tcp_dst               = "uint16_t",
    tcp_dst_masked        = "uint16_t",
    udp_src               = "uint16_t",
    udp_src_masked        = "uint16_t",
    udp_dst               = "uint16_t",
    udp_dst_masked        = "uint16_t",
    sctp_src              = "uint16_t",
    sctp_src_masked       = "uint16_t",
    sctp_dst              = "uint16_t",
    sctp_dst_masked       = "uint16_t",
    icmpv4_type           = "uint8_t",
    icmpv4_type_masked    = "uint8_t",
    icmpv4_code           = "uint8_t",
    icmpv4_code_masked    = "uint8_t",
    arp_op                = "uint16_t",
    arp_op_masked         = "uint16_t",
    arp_spa               = "uint32_t",
    arp_spa_masked        = "uint32_t",
    arp_tpa               = "uint32_t",
    arp_tpa_masked        = "uint32_t",
    arp_sha               = "of_mac_addr_t",
    arp_sha_masked        = "of_mac_addr_t",
    arp_tha               = "of_mac_addr_t",
    arp_tha_masked        = "of_mac_addr_t",
    ipv6_src              = "of_ipv6_t",
    ipv6_src_masked       = "of_ipv6_t",
    ipv6_dst              = "of_ipv6_t",
    ipv6_dst_masked       = "of_ipv6_t",
    ipv6_flabel           = "uint32_t",
    ipv6_flabel_masked    = "uint32_t",
    icmpv6_type           = "uint8_t",
    icmpv6_type_masked    = "uint8_t",
    icmpv6_code           = "uint8_t",
    icmpv6_code_masked    = "uint8_t",
    ipv6_nd_target        = "of_ipv6_t",
    ipv6_nd_target_masked = "of_ipv6_t",
    ipv6_nd_sll           = "of_mac_addr_t",
    ipv6_nd_sll_masked    = "of_mac_addr_t",
    ipv6_nd_tll           = "of_mac_addr_t",
    ipv6_nd_tll_masked    = "of_mac_addr_t",
    mpls_label            = "uint32_t",
    mpls_label_masked     = "uint32_t",
    mpls_tc               = "uint8_t",
    mpls_tc_masked        = "uint8_t"
    # FIXME Add 1.3 oxm elts
    )

oxm_wire_type = dict(
    in_port               = (0 << 1),
    in_port_masked        = (0 << 1) + 1,
    in_phy_port           = (1 << 1),
    in_phy_port_masked    = (1 << 1) + 1,
    metadata              = (2 << 1),
    metadata_masked       = (2 << 1) + 1,
    eth_dst               = (3 << 1),
    eth_dst_masked        = (3 << 1) + 1,
    eth_src               = (4 << 1),
    eth_src_masked        = (4 << 1) + 1,
    eth_type              = (5 << 1),
    eth_type_masked       = (5 << 1) + 1,
    vlan_vid              = (6 << 1),
    vlan_vid_masked       = (6 << 1) + 1,
    vlan_pcp              = (7 << 1),
    vlan_pcp_masked       = (7 << 1) + 1,
    ip_dscp               = (8 << 1),
    ip_dscp_masked        = (8 << 1) + 1,
    ip_ecn                = (9 << 1),
    ip_ecn_masked         = (9 << 1) + 1,
    ip_proto              = (10 << 1),
    ip_proto_masked       = (10 << 1) + 1,
    ipv4_src              = (11 << 1),
    ipv4_src_masked       = (11 << 1) + 1,
    ipv4_dst              = (12 << 1),
    ipv4_dst_masked       = (12 << 1) + 1,
    tcp_src               = (13 << 1),
    tcp_src_masked        = (13 << 1) + 1,
    tcp_dst               = (14 << 1),
    tcp_dst_masked        = (14 << 1) + 1,
    udp_src               = (15 << 1),
    udp_src_masked        = (15 << 1) + 1,
    udp_dst               = (16 << 1),
    udp_dst_masked        = (16 << 1) + 1,
    sctp_src              = (17 << 1),
    sctp_src_masked       = (17 << 1) + 1,
    sctp_dst              = (18 << 1),
    sctp_dst_masked       = (18 << 1) + 1,
    icmpv4_type           = (19 << 1),
    icmpv4_type_masked    = (19 << 1) + 1,
    icmpv4_code           = (20 << 1),
    icmpv4_code_masked    = (20 << 1) + 1,
    arp_op                = (21 << 1),
    arp_op_masked         = (21 << 1) + 1,
    arp_spa               = (22 << 1),
    arp_spa_masked        = (22 << 1) + 1,
    arp_tpa               = (23 << 1),
    arp_tpa_masked        = (23 << 1) + 1,
    arp_sha               = (24 << 1),
    arp_sha_masked        = (24 << 1) + 1,
    arp_tha               = (25 << 1),
    arp_tha_masked        = (25 << 1) + 1,
    ipv6_src              = (26 << 1),
    ipv6_src_masked       = (26 << 1) + 1,
    ipv6_dst              = (27 << 1),
    ipv6_dst_masked       = (27 << 1) + 1,
    ipv6_flabel           = (28 << 1),
    ipv6_flabel_masked    = (28 << 1) + 1,
    icmpv6_type           = (29 << 1),
    icmpv6_type_masked    = (29 << 1) + 1,
    icmpv6_code           = (30 << 1),
    icmpv6_code_masked    = (30 << 1) + 1,
    ipv6_nd_target        = (31 << 1),
    ipv6_nd_target_masked = (31 << 1) + 1,
    ipv6_nd_sll           = (32 << 1),
    ipv6_nd_sll_masked    = (32 << 1) + 1,
    ipv6_nd_tll           = (33 << 1),
    ipv6_nd_tll_masked    = (33 << 1) + 1,
    mpls_label            = (34 << 1),
    mpls_label_masked     = (34 << 1) + 1,
    mpls_tc               = (35 << 1),
    mpls_tc_masked        = (35 << 1) + 1
    # FIXME Add 1.3 oxm elts
)

def add_oxm_classes_1_2(classes, version):
    """
    Add the OXM classes to object passed.  This is a dictionary
    indexed by class name whose value is an array of member objects.
    """
    # First the parent class:
    if version not in [of_g.VERSION_1_2, of_g.VERSION_1_3]:
        return

    members = []
    classes["of_oxm"] = []
    of_g.ordered_classes[version].append("of_oxm")
    members.append(dict(name="type_len", m_type="uint32_t"))
    classes["of_oxm_header"] = members
    of_g.ordered_classes[version].append("of_oxm_header")

    for oxm in oxm_types:
        members = []
        # Assert oxm_types[oxm] in of_base_types
        m_type = oxm_types[oxm]
        if m_type in of_g.of_mixed_types:
            m_type = of_g.of_mixed_types[m_type][version]
        # m_name = "value_" + of_g.of_base_types[m_type]["short_name"]
        members.append(dict(name="type_len", m_type="uint32_t"))
        # members.append(dict(name=m_name, m_type=oxm_types[oxm]))
        members.append(dict(name="value", m_type=oxm_types[oxm]))
        if oxm.find("_masked") > 0:
            members.append(dict(name="value_mask", m_type=oxm_types[oxm]))
            
        name = "of_oxm_" + oxm
        of_g.ordered_classes[version].append(name)
        classes[name] = members
        
# /* Header for OXM experimenter match fields. */
# struct ofp_oxm_experimenter_header {
#     uint32_t oxm_header;        /* oxm_class = OFPXMC_EXPERIMENTER */
#     uint32_t experimenter;      /* Experimenter ID which takes the same
#                                    form as in struct ofp_experimenter_header. */
# };


# enum ofp_vlan_id {
#     OFPVID_PRESENT = 0x1000, 
#     OFPVID_NONE    = 0x0000, 
# };

# #define OFP_VLAN_NONE      OFPVID_NONE
