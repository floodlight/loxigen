# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

import pyparsing as P

kw = P.Keyword
s = P.Suppress
lit = P.Literal

# Useful for marking the type of a parse result (matches the empty string, but
# shows up in the result)
tag = lambda name: P.Empty().setParseAction(P.replaceWith(name))

word = P.Word(P.alphanums + '_')
integer = (
            P.Combine('0x' - P.Word('0123456789abcdefABCDEF') |
            P.Word('0123456789'))
          ).setParseAction(lambda x: int(x[0], 0))

identifier = word.copy().setName("identifier")

# Type names
enum_type = kw("enum") - word
scalar_type = tag("scalar") + word
array_type = tag("array") + P.Combine(word + lit('[') - P.Word(P.alphanums + '_') - lit(']'))
list_type = tag("list") + P.Combine(kw('list') - lit('(') - identifier - lit(')'))
any_type = P.Group(enum_type | array_type | list_type | scalar_type).setName("type name")

# Structs
pad_member = P.Group(kw('pad') - s('(') - integer - s(')'))
discriminator_member = P.Group(tag('discriminator') + any_type + identifier + s('==') + s('?'))
field_length_member = P.Group(tag('field_length') + any_type + identifier + \
    s('==') + s('length') + s('(') + identifier + s(')'))
type_member = P.Group(tag('type') + any_type + identifier + s('==') + integer)
data_member = P.Group(tag('data') + any_type - identifier)

struct_param_name = kw("align") | kw("length_includes_align")
struct_param = P.Group(struct_param_name - s('=') - word)
struct_param_list = P.Forward()
struct_param_list << struct_param + P.Optional(s(',') - P.Optional(struct_param_list))

struct_member = pad_member | type_member | discriminator_member | field_length_member | data_member;
parent = (s(':') - identifier) | tag(None)
struct = kw('struct') - identifier - P.Group(P.Optional(s('(') - struct_param_list - s(')'))) - parent - s('{') + \
         P.Group(P.ZeroOrMore(struct_member - s(';'))) + \
         s('}') - s(';')

# Enums
enum_param_name = kw("wire_type") | kw("bitmask") | kw("complete") | kw("stable")
enum_param = P.Group(enum_param_name  - s('=') - word)
enum_param_list = P.Forward()
enum_param_list << enum_param + P.Optional(s(',') + P.Optional(enum_param_list))

enum_member_param_name = kw("virtual")
enum_member_param = P.Group(enum_member_param_name  - s('=') - word)
enum_member_param_list = P.Forward()
enum_member_param_list << enum_member_param + P.Optional(s(',') + P.Optional(enum_member_param_list))

enum_member = P.Group(identifier - P.Group(P.Optional(s('(') - enum_member_param_list - s(')'))) - s('=') + integer)
enum_list = P.Forward()
enum_list << enum_member + P.Optional(s(',') + P.Optional(enum_list))
enum = kw('enum') - identifier - P.Group(P.Optional(s('(') - enum_param_list - s(')'))) - s('{') + \
         P.Group(P.Optional(enum_list)) + \
         s('}') - s(';')

# Metadata
metadata_key = P.Or(kw("version")).setName("metadata key")
metadata = tag('metadata') + s('#') - metadata_key - word

grammar = P.ZeroOrMore(P.Group(struct) | P.Group(enum) | P.Group(metadata))
grammar.ignore(P.cppStyleComment)

def parse(src):
    """
    Given an input string, return the AST.

    The AST is a low-level representation of the input. It changes frequently
    with the input file syntax. The frontend.py module transforms the AST
    into the OFInput represntation.
    """
    return grammar.parseString(src, parseAll=True).asList()
