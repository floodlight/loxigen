:: # Copyright 2013, Big Switch Networks, Inc.
:: #
:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
:: # the following special exception:
:: #
:: # LOXI Exception
:: #
:: # As a special exception to the terms of the EPL, you may distribute libraries
:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
:: # from the LoxiGen Libraries and the notice provided below is (i) included in
:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
:: # documentation for the LoxiGen Libraries, if distributed in binary form.
:: #
:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
:: #
:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
:: # a copy of the EPL at:
:: #
:: # http://www.eclipse.org/legal/epl-v10.html
:: #
:: # Unless required by applicable law or agreed to in writing, software
:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
:: # EPL for the specific language governing permissions and limitations
:: # under the EPL.
::
:: import of_g
:: ir = of_g.ir
:: include('_copyright.lua')

:: include('_ofreader.lua')

:: include('_oftype_readers.lua')

p_of = Proto ("of", "OpenFlow")

local openflow_versions = {
:: for (version, name) in of_g.param_version_names.items():
    [${version}] = "${name}",
:: #endfor
}

:: for version, ofproto in ir.items():
:: for enum in ofproto.enums:
local enum_v${version}_${enum.name} = {
:: for (name, value) in enum.values:
    [${value}] = "${name}",
:: #endfor
}

:: #endfor

:: #endfor


:: values = {
::     'of13.flow_mod.type': 'enum_v4_ofp_type',
::     'of13.error_msg.type': 'enum_v4_ofp_type',
::     'of13.stats_request.type': 'enum_v4_ofp_type',
::     'of13.stats_request.stats_type': 'enum_v4_ofp_stats_type',
::     'of13.stats_request.flags': 'enum_v4_ofp_stats_request_flags',
::     'of13.stats_reply.type': 'enum_v4_ofp_type',
::     'of13.stats_reply.stats_type': 'enum_v4_ofp_stats_type',
::     'of13.stats_reply.flags': 'enum_v4_ofp_stats_reply_flags',
::     'of13.flow_mod.table_id': 'enum_v4_ofp_table',
::     'of13.flow_mod._command': 'enum_v4_ofp_flow_mod_command',
::     'of13.flow_mod.out_port': 'enum_v4_ofp_port',
::     'of13.flow_mod.out_group': 'enum_v4_ofp_group',
::     'of13.error_msg.err_type': 'enum_v4_ofp_error_type',
::     'of13.port_mod.type': 'enum_v4_ofp_type',
::     'of13.hello.type': 'enum_v4_ofp_type',
::     'of13.features_request.type': 'enum_v4_ofp_type',
::     'of13.features_reply.type': 'enum_v4_ofp_type',
::     'of13.barrier_request.type': 'enum_v4_ofp_type',
::     'of13.barrier_reply.type': 'enum_v4_ofp_type',
::     'of13.echo_request.type': 'enum_v4_ofp_type',
::     'of13.echo_reply.type': 'enum_v4_ofp_type',
::     'of13.match_t.type': 'enum_v4_ofp_match_type'
:: }


fields = {}
:: for field in fields:
:: if field.type in ["uint8", "uint16", "uint32", "uint64"]:
:: if field.fullname in values:
fields[${repr(field.fullname)}] = ProtoField.${field.type}("${field.fullname}", "${field.name}", base.${field.base}, ${values[field.fullname]})
:: else:
fields[${repr(field.fullname)}] = ProtoField.${field.type}("${field.fullname}", "${field.name}", base.${field.base})
:: #endif
:: elif field.type in ["ipv4", "ipv6", "ether", "bytes", "stringz"]:
fields[${repr(field.fullname)}] = ProtoField.${field.type}("${field.fullname}", "${field.name}")
:: else:
:: raise NotImplementedError("unknown Wireshark type " + field.type)
:: #endif
:: #endfor

p_of.fields = {
:: for field in fields:
    fields[${repr(field.fullname)}],
:: #endfor
}

-- Subclass maps for virtual classes
:: for version, ofproto in ir.items():
:: for ofclass in ofproto.classes:
:: if ofclass.virtual:
${ofclass.name}_v${version}_dissectors = {}
:: #endif
:: #endfor
:: #endfor

--- Dissectors for each class

:: for version, ofproto in ir.items():
:: for ofclass in ofproto.classes:
:: name = 'dissect_%s_v%d' % (ofclass.name, version)
:: include('_ofclass_dissector.lua', name=name, ofclass=ofclass, version=version)
:: if ofclass.superclass:
:: discriminator = ofproto.class_by_name(ofclass.superclass).discriminator
:: discriminator_value = ofclass.member_by_name(discriminator.name).value
${ofclass.superclass}_v${version}_dissectors[${discriminator_value}] = ${name}

:: #endif
:: #endfor
:: #endfor

local of_message_dissectors = {
:: for version in ir:
    [${version}] = of_header_v${version}_dissectors,
:: #endfor
}

function dissect_of_message(buf, root)
    local reader = OFReader.new(buf)
    local subtree = root:add(p_of, buf(0))
    local version_val = buf(0,1):uint()
    local type_val = buf(1,1):uint()

    local protocol = "OF ?"
    if openflow_versions[version_val] then
        protocol = "OF " .. openflow_versions[version_val]
    end

    local info = "unknown"
    if of_message_dissectors[version_val] and of_message_dissectors[version_val][type_val] then
        info = of_message_dissectors[version_val][type_val](reader, subtree)
    end

    return protocol, info
end

function dissect_of_oxm_v3(reader, subtree)
    local type_val = reader.peek(0,4):uint()

    local info = "unknown"
    if of_oxm_v3_dissectors[type_val] then
        info = of_oxm_v3_dissectors[type_val](reader, subtree)
    end

    return info
end
-- of dissector function
function p_of.dissector (buf, pkt, root)
    local offset = 0
    repeat
        if buf:len() - offset >= 4 then
            msg_len = buf(offset+2,2):uint()
            if offset + msg_len > buf:len() then
                -- we don't have all the data we need yet
                pkt.desegment_len = offset + msg_len - buf:len()
                return
            end

            protocol, info = dissect_of_message(buf(offset, msg_len), root)

            if offset == 0 then
                pkt.cols.protocol:clear()
                pkt.cols.info:clear()
            else
                pkt.cols.protocol:append(" + ")
                pkt.cols.info:append(" + ")
            end
            pkt.cols.protocol:append(protocol)
            pkt.cols.info:append(info)
            offset = offset + msg_len
        else
            -- we don't have all of length field yet
            pkt.desegment_len = DESEGMENT_ONE_MORE_SEGMENT
            return
        end
    until offset >= buf:len()
end

-- Initialization routine
function p_of.init()
end

-- register a chained dissector for OpenFlow port numbers
local tcp_dissector_table = DissectorTable.get("tcp.port")
tcp_dissector_table:add(6633, p_of)
tcp_dissector_table:add(6653, p_of)
