//:: # Copyright 2013, Big Switch Networks, Inc.
//:: #
//:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
//:: # the following special exception:
//:: #
//:: # LOXI Exception
//:: #
//:: # As a special exception to the terms of the EPL, you may distribute libraries
//:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
//:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
//:: # from the LoxiGen Libraries and the notice provided below is (i) included in
//:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
//:: # documentation for the LoxiGen Libraries, if distributed in binary form.
//:: #
//:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//:: #
//:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
//:: # a copy of the EPL at:
//:: #
//:: # http::: #www.eclipse.org/legal/epl-v10.html
//:: #
//:: # Unless required by applicable law or agreed to in writing, software
//:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//:: # EPL for the specific language governing permissions and limitations
//:: # under the EPL.
//::
//:: import itertools
//:: include('_copyright.java')

//:: include('_autogen.java')

package ${package};

//:: include('_imports.java')
import ${enum.package}.${enum.name};

public class ${class_name} {
    //:: wire_type = enum.wire_type(version)
    //:: int_wire_type = enum.wire_type(version).pub_type
    //:: unsorted_entries = []
    //:: for entry in enum.entries:
    //::   if entry.has_value(version):
    //::     unsorted_entries.append( (entry, entry.value(version)) )
    //::   #endif
    //:: #endfor
    //:: entries = sorted(unsorted_entries, key=lambda tup: tup[1])

    //:: for entry, _ in entries:
    public final static ${int_wire_type} ${entry.name}_VAL = ${entry.format_value(version)};
    //:: #endfor

    public static ${enum.name} readFrom(ByteBuf bb) throws OFParseError {
        try {
            return ofWireValue(${wire_type.read_op(version)});
        } catch (IllegalArgumentException e) {
            throw new OFParseError(e);
        }
    }

    public static void writeTo(ByteBuf bb, ${enum.name} e) {
        ${wire_type.write_op(version=version, name="toWireValue(e)")};
    }

    public static void putTo(${enum.name} e, PrimitiveSink sink) {
        ${wire_type.funnel_op(version=version, name="toWireValue(e)")};
    }

    public static ${enum.name} ofWireValue(${int_wire_type} val) {
        switch(val) {
        //:: for entry, _ in entries:
            case ${entry.name}_VAL:
                return ${enum.name}.${entry.name};
        //:: #endfor
            default:
                throw new IllegalArgumentException("Illegal wire value for type ${enum.name} in version ${version}: " + val);
        }
    }


    public static ${int_wire_type} toWireValue(${enum.name} e) {
        switch(e) {
        //:: for entry, _ in entries:
            case ${entry.name}:
                return ${entry.name}_VAL;
        //:: #endfor
            default:
                throw new IllegalArgumentException("Illegal enum value for type ${enum.name} in version ${version}: " + e);
        }
    }

}
