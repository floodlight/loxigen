//:: # Copyright 2013, Big Switch Networks, Inc.
//:: #
//:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
//:: # the following special exception:
//:: #
//:: # LOXI Exception
//:: #
//:: # As a special exception to the terms of the EPL, you may distribute libraries
//:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
//:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
//:: # from the LoxiGen Libraries and the notice provided below is (i) included in
//:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
//:: # documentation for the LoxiGen Libraries, if distributed in binary form.
//:: #
//:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//:: #
//:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
//:: # a copy of the EPL at:
//:: #
//:: # http::: #www.eclipse.org/legal/epl-v10.html
//:: #
//:: # Unless required by applicable law or agreed to in writing, software
//:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//:: # EPL for the specific language governing permissions and limitations
//:: # under the EPL.
//::
//:: import itertools
//:: import of_g
//:: include('_copyright.java')

//:: include('_autogen.java')

package org.openflow.protocol;
import java.util.Collections;
import java.util.List;
import org.openflow.protocol.actions.OFAction;
import org.openflow.protocol.instructions.OFInstruction;
import org.openflow.protocol.match.*;
import org.openflow.types.*;
import org.openflow.types.*;
import org.openflow.util.*;
import org.openflow.exceptions.*;
import org.jboss.netty.buffer.ChannelBuffer;

class ${impl_class} implements ${msg.interface_name} {
//:: if msg.is_fixed_length(version):
    private static final int LENGTH = ${msg.min_length(version) };
//:: else:
    private static final int MINIMUM_LENGTH = ${msg.min_length(version) };
//:: #endif

//:: for prop in msg.properties_for_version(version):
    private final static ${prop.java_type.public_type} ${prop.default_name} = ${prop.default_value};
//:: #end
    private boolean xidSet;
    private final int xid;

    // OF message fields
//:: for prop in msg.properties_for_version(version):
    private final ${prop.java_type.public_type} ${prop.name};
//:: #endfor

    // Constructor
    ${impl_class}(${
        ", ".join(["int xid" ] + [ "%s %s" %(prop.java_type.public_type, prop.name) for prop in msg.properties_for_version(version) ])}) {
        this.xidSet = true;
        this.xid = xid;
//:: for prop in msg.properties_for_version(version):
        this.${prop.name} = ${prop.name};
//:: #endfor
    }

    ${impl_class}(${
        ", ".join("%s %s" %(prop.java_type.public_type, prop.name) for prop in msg.properties_for_version(version)) }) {
        this.xidSet = false;
        this.xid = 0;
//:: for prop in msg.properties_for_version(version):
        this.${prop.name} = ${prop.name};
//:: #endfor
    }

    @Override
    public int getXid() {
        return xid;
    }

    @Override
    public boolean isXidSet() {
        return xidSet;
    }

    @Override
    public OFType getType() {
        return OFType.${msg.constant_name};
    }

    @Override
    public OFVersion getVersion() {
        return OFVersion.${version.constant_version};
    }

    // Accessors for OF message fields
//:: for prop in msg.all_properties():
    @Override
    public ${prop.java_type.public_type} get${prop.title_name}()${ "" if msg.property_in_version(prop, version) else "throws UnsupportedOperationException"} {
//:: if msg.property_in_version(prop, version):
        return ${prop.name};
//:: else:
        throw new UnsupportedOperationException("Property ${prop.name} not supported in version #{version}");
//:: #endif
    }
//:: #endfor

    public ${msg.interface_name}.Builder createBuilder() {
        return new BuilderImplWithParent(this);
    }

    static class BuilderImplWithParent implements ${msg.interface_name}.Builder {
        final ${impl_class} parentMessage;
        private boolean xidSet;
        private int xid;

        // OF message fields
//:: for prop in msg.properties_for_version(version):
        private boolean ${prop.name}Set;
        private ${prop.java_type.public_type} ${prop.name};
//:: #endfor

        BuilderImplWithParent(${impl_class} parentMessage) {
            this.parentMessage = parentMessage;
        }

//:: for prop in msg.all_properties():
        @Override
        public ${prop.java_type.public_type} get${prop.title_name}()${ "" if msg.property_in_version(prop, version) else " throws UnsupportedOperationException"} {
//:: if msg.property_in_version(prop, version):
            return ${prop.name};
//:: else:
            throw new UnsupportedOperationException("Property ${prop.name} not supported in version #{version}");
//:: #endif
        }
        @Override
        public ${msg.interface_name}.Builder set${prop.title_name}(${prop.java_type.public_type} ${prop.name})${ "" if msg.property_in_version(prop, version) else " throws UnsupportedOperationException"} {
//:: if msg.property_in_version(prop, version):
            this.${prop.name} = ${prop.name};
            this.${prop.name}Set = true;
            return this;
//:: else:
        throw new UnsupportedOperationException("Property ${prop.name} not supported in version #{version}");
//:: #endif
        }
//:: #endfor
        @Override
        public ${msg.interface_name} getMessage() {
            if(this.xidSet) {
                return new ${impl_class}(
                    ${",\n                      ".join(
                         [ "xid" ] +
                         [ "this.{0}Set ? this.{0} : parentMessage.{0}".format(prop.name)
                             for prop in msg.properties_for_version(version)])}
                    );
            } else {
                return new ${impl_class}(
                    ${",\n                      ".join(
                         [ "this.{0}Set ? this.{0} : parentMessage.{0}".format(prop.name)
                             for prop in msg.properties_for_version(version)])}
                    );
            }
        }
    }

    static class BuilderImpl implements ${msg.interface_name}.Builder {
        private boolean xidSet;
        private int xid;

        // OF message fields
//:: for prop in msg.properties_for_version(version):
        private boolean ${prop.name}Set;
        private ${prop.java_type.public_type} ${prop.name};
//:: #endfor

//:: for prop in msg.all_properties():
        @Override
        public ${prop.java_type.public_type} get${prop.title_name}()${ "" if msg.property_in_version(prop, version) else " throws UnsupportedOperationException"} {
//:: if msg.property_in_version(prop, version):
            return ${prop.name};
//:: else:
            throw new UnsupportedOperationException("Property ${prop.name} not supported in version #{version}");
//:: #endif
        }
        @Override
        public ${msg.interface_name}.Builder set${prop.title_name}(${prop.java_type.public_type} ${prop.name})${ "" if msg.property_in_version(prop, version) else " throws UnsupportedOperationException"} {
//:: if msg.property_in_version(prop, version):
            this.${prop.name} = ${prop.name};
            this.${prop.name}Set = true;
            return this;
//:: else:
        throw new UnsupportedOperationException("Property ${prop.name} not supported in version #{version}");
//:: #endif
        }
//:: #endfor
        @Override
        public ${msg.interface_name} getMessage() {
            if(this.xidSet) {
                return new ${impl_class}(
                    ${",\n                      ".join(
                         [ "xid" ] +
                         [ "this.{0}Set ? this.{0} : {1}.{2}".format(prop.name, impl_class, prop.default_name)
                             for prop in msg.properties_for_version(version)])}
                    );
            } else {
                return new ${impl_class}(
                    ${",\n                      ".join(
                         [ "this.{0}Set ? this.{0} : {1}.{2}".format(prop.name, impl_class, prop.default_name)
                             for prop in msg.properties_for_version(version)])}
                    );
            }
        }
    }

    final static Reader READER = new Reader();
    static class Reader implements OFMessageReader<${msg.interface_name}> {
        @Override
        public ${msg.interface_name} readFrom(ChannelBuffer bb) throws OFParseError {
            byte version = bb.readByte();
            if (version != (byte) ${version.int_version})
                throw new OFParseError("Wrong version: Expected=${version.int_version}, got="+version);

            byte type = bb.readByte();
            if(type != ${msg.wire_type(version)})
                throw new OFParseError("Wrong message type: Expected=${msg.constant_name}, got="+type);

            int length = bb.readUnsignedShort();
//:: if msg.is_fixed_length(version):
            if(length != LENGTH)
                throw new OFParseError("Wrong message length: Expected="+LENGTH +", got="+length);
//:: else:
            if(length < MINIMUM_LENGTH)
                throw new OFParseError("Insufficient message length: minimum length="+MINIMUM_LENGTH +", got="+length);
//:: #endif
            int xid = bb.readInt();
//:: for prop in msg.properties_for_version(version, skip_pads=False):
//:: if prop.is_pad:
            // pad: ${prop.length} bytes
            bb.skipBytes(${prop.length});
//:: else:
            ${prop.java_type.public_type} ${prop.name} = ${prop.java_type.read_op(version)};
//:: #endif
//:: #endfor
                return new ${impl_class}(
                    ${",\n                      ".join(
                         [ "xid" ] + [ prop.name for prop in msg.properties_for_version(version)])}
                    );
        }
    }

}
