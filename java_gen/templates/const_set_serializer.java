//:: # Copyright 2013, Big Switch Networks, Inc.
//:: #
//:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
//:: # the following special exception:
//:: #
//:: # LOXI Exception
//:: #
//:: # As a special exception to the terms of the EPL, you may distribute libraries
//:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
//:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
//:: # from the LoxiGen Libraries and the notice provided below is (i) included in
//:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
//:: # documentation for the LoxiGen Libraries, if distributed in binary form.
//:: #
//:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//:: #
//:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
//:: # a copy of the EPL at:
//:: #
//:: # http::: #www.eclipse.org/legal/epl-v10.html
//:: #
//:: # Unless required by applicable law or agreed to in writing, software
//:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
//:: # EPL for the specific language governing permissions and limitations
//:: # under the EPL.
//::
//:: import itertools
//:: include('_copyright.java')

//:: include('_autogen.java')

package ${package};

//:: include('_imports.java')

import ${enum.package}.${enum.name};

public class ${class_name} {
    //:: wire_type = enum.wire_type(version)
    //:: int_wire_type = enum.wire_type(version).pub_type
    //:: entries = []
    //:: for entry in enum.entries:
    //::   if entry.has_value(version):
    //::     entries.append(entry)
    //::   #endif
    //:: #endfor

    //:: for entry in entries:
    public final static ${int_wire_type} ${entry.name}_VAL = ${entry.format_value(version)};
    //:: #endfor

    public static Set<${enum.name}> readFrom(ByteBuf bb) throws OFParseError {
        try {
            return ofWireValue(${wire_type.read_op(version)});
        } catch (IllegalArgumentException e) {
            throw new OFParseError(e);
        }
    }

    public static void writeTo(ByteBuf bb, Set<${enum.name}> set) {
        ${wire_type.write_op(version=version, name="toWireValue(set)")};
    }

    public static void putTo(Set<${enum.name}> set, PrimitiveSink sink) {
        ${wire_type.funnel_op(version=version, name="toWireValue(set)")};
    }


    public static Set<${enum.name}> ofWireValue(${int_wire_type} val) {
        EnumSet<${enum.name}> set = EnumSet.noneOf(${enum.name}.class);

        //:: last_group = None
        //:: for entry in entries:
        //::    if entry.is_mask:
        //::        continue
        //::    #endif
        //::    group = entry.masked_enum_group
        //::    if group:
        ${"else " if group == last_group else "" }if((val & ${group.mask}_VAL) == ${entry.name}_VAL)
            set.add(${enum.name}.${entry.name});
        //::       last_group = group
        //::    else:
        if((val & ${entry.name}_VAL) != 0)
            set.add(${enum.name}.${entry.name});
        //::       last_group = None
        //::    #endif
        //:: #endfor
        return Collections.unmodifiableSet(set);
    }

    public static ${int_wire_type} toWireValue(Set<${enum.name}> set) {
        ${int_wire_type} wireValue = 0;

        for(${enum.name} e: set) {
            switch(e) {
                //:: for entry in entries:
                //::    if entry.is_mask:
                //::        continue
                //::    #endif
                case ${entry.name}:
                    wireValue |= ${entry.name}_VAL;
                    break;
                //:: #endfor
                default:
                    throw new IllegalArgumentException("Illegal enum value for type ${enum.name} in version ${version}: " + e);
            }
        }
        return wireValue;
    }

}
