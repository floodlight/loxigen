# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

##
# @brief Translation data between openflow.h and LOXI
#

import re
import sys

def loxi_name(ident):
    """
    Return the LOXI name of an openflow.h identifier
    """

    # Order at the outer level matters as super strings are listed first
    rules = [
# The following are for #define macros and have highest precedence
        dict(OFP_MAX_TABLE_NAME_LEN = "OF_MAX_TABLE_NAME_LEN"),
        dict(OFP_MAX_PORT_NAME_LEN = "OF_MAX_PORT_NAME_LEN"),
        dict(OFP_TCP_PORT = "OF_TCP_PORT"),
        dict(OFP_SSL_PORT = "OF_SSL_PORT"),
        dict(OFP_ETH_ALEN = "OF_ETH_ALEN"),
        dict(OFP_DEFAULT_MISS_SEND_LEN = "OF_DEFAULT_MISS_SEND_LEN"),
        dict(OFP_VLAN_NONE = "OF_VLAN_UNTAGGED"),
        dict(OFP_DL_TYPE_ETH2_CUTOFF = "OF_DL_TYPE_ETH2_CUTOFF"),
        dict(OFP_DL_TYPE_NOT_ETH_TYPE = "OF_DL_TYPE_NOT_ETH_TYPE"),
        dict(OFP_FLOW_PERMANENT = "OF_FLOW_PERMANENT"),
        dict(OFP_DEFAULT_PRIORITY = "OF_DEFAULT_PRIORITY"),
        dict(DESC_STR_LEN = "OF_DESC_STR_LEN"),
        dict(SERIAL_NUM_LEN = "OF_SERIAL_NUM_LEN"),
        dict(OFPQ_ALL = "OF_QUEUE_ALL"),
        dict(OFPQ_MIN_RATE_UNCFG = "OF_QUEUE_MIN_RATE_UNCFG"),
        dict(OFPQ_MAX_RATE_UNCFG = "OF_QUEUE_MAX_RATE_UNCFG"),
        dict(OFP_NO_BUFFER = "OF_BUFFER_ID_NO_BUFFER"),

# These are for enums; they map the prefixes
        dict(OFPP_MAX = "OF_PORT_NUMBER_MAX"), # Special case
        dict(OFPP_TABLE = "OF_PORT_DEST_USE_TABLE"), # Special case
        dict(OFPP_ANY = "OF_PORT_DEST_WILDCARD"), # Special case
        dict(OFPTC_ = "OF_TABLE_CONFIG_"),
        dict(OFPIEH_ = "OF_IPV6_EXT_HDR_FLAG_"),
        dict(OFPMBT_ = "OF_METER_BAND_TYPE_"),
        dict(OFPMC_ = "OF_METER_MOD_COMMAND_"),
        dict(OFPMF_ = "OF_METER_FLAG_"),
        dict(OFPTFFC_ = "OF_TABLE_REQUEST_FAILED_"),
        dict(OFPMMFC_ = "OF_METER_MOD_FAILED_"),
        dict(OFPPR_ = "OF_PORT_CHANGE_REASON_"),
        dict(OFPPMFC_ = "OF_PORT_MOD_FAILED_"),
        dict(OFPP_ = "OF_PORT_DEST_"),
        dict(OFPRRFC_ = "OF_ROLE_REQUEST_FAILED_"),
        dict(OFPRR_ = "OF_FLOW_REMOVED_REASON_"),
        dict(OFPR_ = "OF_PACKET_IN_REASON_"),
        dict(OFPC_FRAG_ = "OF_CONFIG_FRAG_"),
        dict(OFPC_INVALID_ = "OF_CONFIG_INVALID_"),
        dict(OFPCML_ = "OF_CONTROLLER_PKT_"),
        dict(OFPCR_ROLE_ = "OF_CONTROLLER_ROLE_"),
        dict(OFPC_ = "OF_CAPABILITIES_FLAG_"),
        dict(OFPPC_ = "OF_PORT_CONFIG_FLAG_"),
        dict(OFPPS_ = "OF_PORT_STATE_FLAG_"),
        dict(OFPPF_ = "OF_PORT_FEATURE_FLAG_"),
        dict(OFPTT_ = "OF_TABLE_"),
        dict(OFPT_ = "OF_OBJ_TYPE_"),
        dict(OFPMT_ = "OF_MATCH_TYPE_"),
        dict(OFPM_ = "OF_METER_"),
        dict(OFPXMC_ = "OF_OXM_CLASS_"),
        dict(OFPVID_ = "OF_VLAN_TAG_"),
        dict(OFPGC_ = "OF_GROUP_MOD_COMMAND_"),
        dict(OFPGT_ = "OF_GROUP_TYPE_"),
        dict(OFPG_ = "OF_GROUP_"),
        dict(OFPET_ = "OF_ERROR_TYPE_"),
        dict(OFPFC_ = "OF_FLOW_MOD_COMMAND_"),
        dict(OFPHFC_ = "OF_HELLO_FAILED_"),
        dict(OFPBRC_ = "OF_REQUEST_FAILED_"),
        dict(OFPBAC_ = "OF_ACTION_FAILED_"),
        dict(OFPBIC_ = "OF_INSTRUCTION_FAILED_"),
        dict(OFPBMC_ = "OF_MATCH_FAILED_"),
        dict(OFPGMFC_ = "OF_GROUP_MOD_FAILED_"),
        dict(OFPTMFC_ = "OF_TABLE_MOD_FAILED_"),
        dict(OFPFMFC_ = "OF_FLOW_MOD_FAILED_"),
        dict(OFPQOFC_ = "OF_QUEUE_OP_FAILED_"),
        dict(OFPSCFC_ = "OF_SWITCH_CONFIG_FAILED_"),
        dict(OFPQCFC_ = "OF_SWITCH_CONFIG_FAILED_"), # See EXT-208
        dict(OFPAT_ = "OF_ACTION_TYPE_"),
        dict(OFPFW_ = "OF_FLOW_WC_V1_"),
        dict(OFPFF_ = "OF_FLOW_MOD_FLAG_"),
        dict(OFPST_ = "OF_STATS_TYPE_"),
        dict(OFPSF_ = "OF_STATS_REPLY_FLAG_"),
        dict(OFPQT_ = "OF_QUEUE_PROPERTY_"),
        dict(OFPIT_ = "OF_INSTRUCTION_TYPE_"),
        dict(OFPGFC_ = "OF_GROUP_CAPABILITIES_"),
        dict(OFPMP_ = "OF_MULTIPART_"),
        dict(OFPMPF_ = "OF_MULTIPART_FLAG_"),
        dict(OFPTFPT_ = "OF_TABLE_FEATURE_"),
        dict(OFPHET = "OF_HELLO_ELEM_TYPE_"),
        dict(NX_ROLE_ = "OF_NICIRA_CONTROLLER_ROLE_"),
        ]

    for entry in rules:
        for id_from, id_to in entry.items():
            if re.match(id_from, ident):
                return re.sub(id_from, id_to, ident)
    return ident
